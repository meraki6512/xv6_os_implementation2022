# xv6_os_implementation2022
UNIX 기반 OS 학습을 위한 xv6 수정 및 구현

1. add shell program
미국 MIT에서 멀티프로세서 x86 및 RISC-V 시스템을 위해 개발한 교육용 운영체제인 xv6를 설치하고, xv6 하드웨어를 에뮬레이트 하기 위해 QEMU를 설치한다. 또한, 리눅스 환경 내에서 helloworld와 hcat 쉘 프로그램을 작성하고 makefile을 활용해 컴파일하여 생성된 실행 파일을 xv6 상에서 수행한다. 추가로, 부팅 시 가장 먼저 실행하는 프로그램을 ssu_login을 호출하여 로그인 프로세스를 실행하도록 수정한다. 이때, 아이디와 비밀번호를 입력받아, 아이디와 비밀번호 쌍의 리스트로 구성된 list.txt 파일과 비교하고, 일치하면 shell 프로그램(sh)을 fork-exec으로 호출한다.   

2. add system call
xv6에 새로운 시스템 호출을 추가한다. 여러 시스템 호출 추가 방법 중 [1] 인자가 없고 정수값만 리턴하는 시스템 호출과 [2] 정수 등 여러 인수를 받아 간단한 정수 값을 리턴하는 시스템 호출을 추가한다. 
- memsize() 시스템 콜으로 memsize()는 호출한 프로세스의 메모리 사용량을 출력한다. 또한 memsizetest 쉘 프로그램을 구현하여 memsize()를 호출하고 실행을 확인한다. 이때, malloc 전후의 프로세스 메모리 사용량을 비교, 분석하여 그 차이가 4096 byte인 이유를 설명한다.
- trace() 시스템 콜으로 추적할 시스템 콜을 지정하는 정수[mask]를 인자로 받아, 시스템 콜 번호가 마스크에 설정되어 있는 경우 각 시스템 콜이 리턴될 때, pid, syscall 이름, 리턴 값을 출력한다. 이때, trace() 시스템 콜은 호출한 프로세스와 호출 이후 생성(fork)하는 모든 자식 프로세스에 대한 trace mask를 활성화해야하고, 다른 프로세스에는 영향을 미치면 안된다. 또한 ssu_trace 쉘 프로그램을 구현하여 trace()를 호출하고 실행을 확인한다. 

3. update scheduler
스케줄링은 다중 프로그래밍을 가능하게 하는 운영체제 커널의 기본 기능이다. xv6는 다음 실행할 프로세스를 process table을 순회하며 RUNNABLE 상태의 프로세스를 순차적으로 선택하는 round robin 스케줄링 기법을 사용한다. 
- 기존 xv6 스케줄러를 round robin 스케줄링 기법에 priority 스케줄링 기법을 더해 수정하는데, 프로세스 실행 흐름에서 새로 생긴 프로세스가 제외되지 않도록 큰 가중치를 부여하는 스케줄러를 구현한다.
- 구현한 스케줄링 함수의 동작 과정을 확인하기 위해 sdebug 명령어 및 weightset() 시스템 콜을 구현한다. sdebug는 프로세스 개수를 특정하여 생성하며, weightset을 호출하고, 생성된 프로세스에 대한 정보(pid, weight, 프로세스 생성 후부터 해당 명령어에 의해 프로세스 정보가 출력되기까지 소요된 시간)를 출력한다. 이때 weightset() 시스템 콜은 매개변수로 입력받은 값을 sdebug 명령어에 의해 생성되는 프로세스의 weight값으로 부여한다. 
- 추가로, debug=1 매개변수 전달을 하며 xv6 빌드할 시, 스케줄링 함수에서 다음 실행될 프로세스를 선택할 때마다 pid, name, weight, priority를 출력하여 다음 실행 프로세스 선정 과정을 디버깅하는 기능을 구현한다.  

4. page replacement
 7가지의 페이지 교체 알고리즘(Optimal, FIFO, LIFO, LRU, LFU, SC, ESC)의 동작 방식을 이해하고 구현한다. 시스템에서 자동 입력과 사용자 파일 입력을 사용하여 각 페이지 알고리즘에 대한 페이지 폴트 횟수를 측정하고, 알고리즘의 성능을 분석한다.   
